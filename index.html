<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Стираемая буква JS</title>
  <style>
    @font-face {
      font-family: 'Arturito';
      src: url('./fonts/arturito.ttf') format('truetype');
      font-weight: 700;
      font-style: normal;
    }

    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }

    .container {
      text-align: center;
    }

    .canvas-container {
      position: relative;
      width: 700px;
      height: 700px;
      margin: 0 auto;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 700px;
      height: 700px;
      cursor: crosshair;
    }

    #bgCanvas { z-index: 1; }
    #fgCanvas { z-index: 2; }

    .instructions {
      margin-top: 16px;
      color: #555;
    }

    .completion-message {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: #E45319;
      font-weight: bold;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 3;
      text-align: right;
    }

    .completion-message.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Стираемая надпись JS</h1>
    <div class="canvas-container">
      <canvas id="bgCanvas" width="700" height="700"></canvas>
      <canvas id="fgCanvas" width="700" height="700"></canvas>
      <div id="completionMessage" class="completion-message">Ты открыл секретную команду <br> hellFire();</div>
    </div>
    <p class="instructions">Проведите мышкой/пальцем по надписи JS, чтобы стереть чёрный слой</p>
  </div>

  <script>
    const WIDTH = 700;
    const HEIGHT = 700;
    const TEXT_J = "J";
    const TEXT_S = "S";
    const FONT = "bold 530px Arturito, sans-serif";
    const VERTICAL_SPACING = 160; // Расстояние между буквами по вертикали
    const HORIZONTAL_SPACING = -20; // Расстояние между буквами по горизонтали

    const bgCanvas = document.getElementById("bgCanvas");
    const fgCanvas = document.getElementById("fgCanvas");
    const bgCtx = bgCanvas.getContext("2d");
    const fgCtx = fgCanvas.getContext("2d");
    const completionMessage = document.getElementById("completionMessage");

    // Ждем загрузки шрифта
    const arturitoFont = new FontFace('Arturito', 'url(./fonts/arturito.ttf)');
    
    arturitoFont.load().then((loadedFont) => {
      document.fonts.add(loadedFont);
      initializeCanvas();
    }).catch((error) => {
      console.error('Ошибка загрузки шрифта:', error);
      initializeCanvas(); // Все равно инициализируем с fallback шрифтом
    });

    function initializeCanvas() {
      // Создаем временный canvas для определения области текста
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = WIDTH;
      tempCanvas.height = HEIGHT;

      // Маска для определения точной области текста
      let textMask = null;

      // Функция для измерения ширины текста
      function getTextWidth(text, ctx) {
        ctx.font = FONT;
        return ctx.measureText(text).width;
      }

      // универсальная функция для отрисовки текста
      function drawText(ctx, fillStyle) {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = fillStyle;
        ctx.font = FONT;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        // Измеряем ширину букв
        const jWidth = getTextWidth(TEXT_J, ctx);
        const sWidth = getTextWidth(TEXT_S, ctx);
        
        // Вычисляем позиции для центрирования
        const totalWidth = jWidth + sWidth + HORIZONTAL_SPACING;
        const startX = (WIDTH - totalWidth) / 2;
        
        // Рисуем букву J
        const jX = startX + jWidth / 2;
        const jY = HEIGHT / 2 - VERTICAL_SPACING / 2;
        ctx.fillText(TEXT_J, jX, jY);
        
        // Рисуем букву S
        const sX = startX + jWidth + HORIZONTAL_SPACING + sWidth / 2;
        const sY = HEIGHT / 2 + VERTICAL_SPACING / 2;
        ctx.fillText(TEXT_S, sX, sY);
      }

      // Создаем маску текста для точной проверки
      function createTextMask() {
        tempCtx.clearRect(0, 0, WIDTH, HEIGHT);
        tempCtx.fillStyle = "#000";
        tempCtx.font = FONT;
        tempCtx.textAlign = "center";
        tempCtx.textBaseline = "middle";
        
        // Измеряем ширину букв
        const jWidth = getTextWidth(TEXT_J, tempCtx);
        const sWidth = getTextWidth(TEXT_S, tempCtx);
        
        // Вычисляем позиции для центрирования
        const totalWidth = jWidth + sWidth + HORIZONTAL_SPACING;
        const startX = (WIDTH - totalWidth) / 2;
        
        // Рисуем букву J
        const jX = startX + jWidth / 2;
        const jY = HEIGHT / 2 - VERTICAL_SPACING / 2;
        tempCtx.fillText(TEXT_J, jX, jY);
        
        // Рисуем букву S
        const sX = startX + jWidth + HORIZONTAL_SPACING + sWidth / 2;
        const sY = HEIGHT / 2 + VERTICAL_SPACING / 2;
        tempCtx.fillText(TEXT_S, sX, sY);
        
        const imageData = tempCtx.getImageData(0, 0, WIDTH, HEIGHT);
        textMask = imageData.data;
      }

      // проверка, полностью ли стёрта надпись
      function checkCompletion() {
        if (!textMask) return false;

        const imageData = fgCtx.getImageData(0, 0, WIDTH, HEIGHT);
        const pixels = imageData.data;

        // Проверяем только пиксели текста
        for (let i = 0; i < pixels.length; i += 4) {
          if (textMask[i + 3] > 128) { 
            // если хотя бы один пиксель текста ещё непрозрачный — возвращаем false
            if (pixels[i + 3] >= 128) {
              return false;
            }
          }
        }

        // если ВСЕ пиксели текста прозрачные
        return true;
      }

      // стираем часть чёрной надписи
      function erase(x, y) {
        fgCtx.globalCompositeOperation = "destination-out";
        fgCtx.beginPath();
        fgCtx.arc(x, y, 30, 0, Math.PI * 2);
        fgCtx.fill();
        fgCtx.globalCompositeOperation = "source-over";
        
        // Проверяем завершение после каждого стирания
        if (checkCompletion() && !completionMessage.classList.contains('show')) {
          completionMessage.classList.add('show');
        }
      }

      // события мыши и касаний
      let isDrawing = false;

      fgCanvas.addEventListener("mousedown", e => {
        isDrawing = true;
        erase(e.offsetX, e.offsetY);
      });

      fgCanvas.addEventListener("mousemove", e => {
        if (isDrawing) erase(e.offsetX, e.offsetY);
      });

      fgCanvas.addEventListener("mouseup", () => isDrawing = false);
      fgCanvas.addEventListener("mouseleave", () => isDrawing = false);

      fgCanvas.addEventListener("touchstart", e => {
        e.preventDefault();
        isDrawing = true;
        const rect = fgCanvas.getBoundingClientRect();
        const touch = e.touches[0];
        erase(touch.clientX - rect.left, touch.clientY - rect.top);
      });

      fgCanvas.addEventListener("touchmove", e => {
        e.preventDefault();
        if (isDrawing) {
          const rect = fgCanvas.getBoundingClientRect();
          const touch = e.touches[0];
          erase(touch.clientX - rect.left, touch.clientY - rect.top);
        }
      });

      fgCanvas.addEventListener("touchend", () => isDrawing = false);

      // запуск
      drawText(bgCtx, "#E45319"); // новый цвет фона
      drawText(fgCtx, "#000");    // чёрная надпись поверх
      createTextMask(); // создаем маску текста для точной проверки
    }
  </script>
</body>
</html>